---
source: /Users/xorcist/.cargo/registry/src/github.com-1ecc6299db9ec823/wasmer-pack-testing-0.6.0/src/autodiscover.rs
---
const { data_view, Slab } = require('./intrinsics.js');
class Sha2 {
  constructor() {
    this._resource0_slab = new Slab();
  }
  addToImports(imports) {
    if (!("canonical_abi" in imports)) imports["canonical_abi"] = {};
    
    imports.canonical_abi['resource_drop_hasher'] = i => {
      this._resource0_slab.remove(i).drop();
    };
    imports.canonical_abi['resource_clone_hasher'] = i => {
      const obj = this._resource0_slab.get(i);
      return this._resource0_slab.insert(obj.clone())
    };
    imports.canonical_abi['resource_get_hasher'] = i => {
      return this._resource0_slab.get(i)._wasm_val;
    };
    imports.canonical_abi['resource_new_hasher'] = i => {
      const registry = this._registry0;
      return this._resource0_slab.insert(new Hasher(i, this));
    };
  }
  
  async instantiate(module, imports) {
    imports = imports || {};
    this.addToImports(imports);
    
    if (module instanceof WebAssembly.Instance) {
      this.instance = module;
    } else if (module instanceof WebAssembly.Module) {
      this.instance = await WebAssembly.instantiate(module, imports);
    } else if (module instanceof ArrayBuffer || module instanceof Uint8Array) {
      const { instance } = await WebAssembly.instantiate(module, imports);
      this.instance = instance;
    } else {
      const { instance } = await WebAssembly.instantiateStreaming(module, imports);
      this.instance = instance;
    }
    this._exports = this.instance.exports;
    this._registry0 = new FinalizationRegistry(this._exports['canonical_abi_drop_hasher']);
  }
  sha256(arg0) {
    const memory = this._exports.memory;
    const realloc = this._exports["canonical_abi_realloc"];
    const free = this._exports["canonical_abi_free"];
    const val0 = arg0;
    const len0 = val0.length;
    const ptr0 = realloc(0, 0, 1, len0 * 1);
    (new Uint8Array(memory.buffer, ptr0, len0 * 1)).set(new Uint8Array(val0.buffer, val0.byteOffset, len0 * 1));
    const ret = this._exports['sha256'](ptr0, len0);
    const ptr1 = data_view(memory).getInt32(ret + 0, true);
    const len1 = data_view(memory).getInt32(ret + 4, true);
    const list1 = new Uint8Array(memory.buffer.slice(ptr1, ptr1 + len1 * 1));
    free(ptr1, len1, 1);
    return list1;
  }
  sha512(arg0) {
    const memory = this._exports.memory;
    const realloc = this._exports["canonical_abi_realloc"];
    const free = this._exports["canonical_abi_free"];
    const val0 = arg0;
    const len0 = val0.length;
    const ptr0 = realloc(0, 0, 1, len0 * 1);
    (new Uint8Array(memory.buffer, ptr0, len0 * 1)).set(new Uint8Array(val0.buffer, val0.byteOffset, len0 * 1));
    const ret = this._exports['sha512'](ptr0, len0);
    const ptr1 = data_view(memory).getInt32(ret + 0, true);
    const len1 = data_view(memory).getInt32(ret + 4, true);
    const list1 = new Uint8Array(memory.buffer.slice(ptr1, ptr1 + len1 * 1));
    free(ptr1, len1, 1);
    return list1;
  }
}

class Hasher {
  constructor(wasm_val, obj) {
    this._wasm_val = wasm_val;
    this._obj = obj;
    this._refcnt = 1;
    obj._registry0.register(this, wasm_val, this);
  }
  
  clone() {
    this._refcnt += 1;
    return this;
  }
  
  drop() {
    this._refcnt -= 1;
    if (this._refcnt !== 0)
    return;
    this._obj._registry0.unregister(this);
    const dtor = this._obj._exports['canonical_abi_drop_hasher'];
    const wasm_val = this._wasm_val;
    delete this._obj;
    delete this._refcnt;
    delete this._wasm_val;
    dtor(wasm_val);
  }
  static sha256(sha2) {
    const ret = sha2._exports['hasher::sha256']();
    return sha2._resource0_slab.remove(ret);
  }
  static sha512(sha2) {
    const ret = sha2._exports['hasher::sha512']();
    return sha2._resource0_slab.remove(ret);
  }
  update(arg1) {
    const memory = this._obj._exports.memory;
    const realloc = this._obj._exports["canonical_abi_realloc"];
    const obj0 = this;
    const val1 = arg1;
    const len1 = val1.length;
    const ptr1 = realloc(0, 0, 1, len1 * 1);
    (new Uint8Array(memory.buffer, ptr1, len1 * 1)).set(new Uint8Array(val1.buffer, val1.byteOffset, len1 * 1));
    this._obj._exports['hasher::update'](this._obj._resource0_slab.insert(obj0.clone()), ptr1, len1);
    return undefined;
  }
  finalize() {
    const memory = this._obj._exports.memory;
    const free = this._obj._exports["canonical_abi_free"];
    const obj0 = this;
    const ret = this._obj._exports['hasher::finalize'](this._obj._resource0_slab.insert(obj0.clone()));
    const ptr1 = data_view(memory).getInt32(ret + 0, true);
    const len1 = data_view(memory).getInt32(ret + 4, true);
    const list1 = new Uint8Array(memory.buffer.slice(ptr1, ptr1 + len1 * 1));
    free(ptr1, len1, 1);
    return list1;
  }
}

module.exports = { Sha2, Hasher };

